# Author: Lee Christensen (@tifkin)

function Get-FileHandlerTrees {
    [CmdletBinding()]
    Param(
        [Parameter(Position=0, Mandatory=$false)]
        [string]
        $ClassesRootPath = 'Registry::HKEY_CLASSES_ROOT'
    )

    $Output = [ordered]@{}

    (Get-Item $ClassesRootPath).GetSubKeyNames() | ?{$_.StartsWith('.')} | %{
        Get-FlattenedRegistryKey -Path "$($ClassesRootPath)\$($_)"
    }
}

<#
$handled = $classicfilehandlerscontainer | ?{
    -not ([string]::IsNullOrEmpty($_.ExtensionShellOpenCommand) -and `
    [string]::IsNullOrEmpty($_.ExtensionShellOpenDelegate) -and `
    [string]::IsNullOrEmpty($_.ExtensionCustomShellCommand) -and `
    [string]::IsNullOrEmpty($_.ExtensionCustomShellDelegate) -and `
    [string]::IsNullOrEmpty($_.ExtensionOpenWithProgIds) -and `
    [string]::IsNullOrEmpty($_.ProgIdShellOpenCommand) -and `
    [string]::IsNullOrEmpty($_.ProgIdShellOpenDelegate) -and `
    [string]::IsNullOrEmpty($_.ProgIdCustomShellCommand) -and `
    [string]::IsNullOrEmpty($_.ProgIdCustomShellDelegate) -and `
    [string]::IsNullOrEmpty($_.Clsid))
} 
#>

function Get-ClassicFileHandlers {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true)]
        [string[]]
        $Name,

        [Parameter(Position=1, Mandatory=$false)]
        [string[]]
        $ClassesRootPath = @('Registry::HKEY_CLASSES_ROOT')
    )

    foreach($RootPath in $ClassesRootPath) {
        if($Name) {
            for($i=0; $i -lt $Name.Count; $i++) {
                if(!$Name[$i].StartsWith('.')) {
                    $Name[$i] = ".$($Name[$i])"
                }
            }
        } else {
            $HKCR = Get-Item $RootPath
            $Name = $HKCR.GetSubKeyNames() | ?{$_.StartsWith('.')}
            $HKCR.Close()
        }

        foreach($Extension in $Name) {
            $ExtObj = Get-FileHandlerObject -ClassesRootPath $RootPath -Extension $Extension

            $ComObj = $null

            if(-not $ExtObj.ProgId) {
                Write-Verbose "Extension '$($Extension)' does not have a ProgId"
            }

            if($ExtObj.ProgId) {
                try {
                    if($ExtObj.ProgId.ToUpper().StartsWith("CLSID\")) {
                        # Handle cases like HKCR\.desklink ! (default) : CLSID\{9E56BE61-C50F-11CF-9A2C-00A0C90A90CE}
                        $ComObj = Get-ComObject -ClassesRootPath $RootPath -Clsid ($ExtObj.ProgId.Substring(6)) -ErrorAction Stop
                    } else {
                        $ComObj = Get-ComObject -ClassesRootPath $RootPath -ProgId $ExtObj.ProgId -ErrorAction Stop
                    }
                } catch {
                    if($_.Exception.Message -notmatch 'does not have an associated CLSID') {
                        Write-Error "Error processing the extension '$($Extension)' (ProgId: $($ExtObj.ProgId)): $_"
                    }
                }
            }


            # TODO: Make extension shell command enumeration robust
            $ExtensionShellOpenCommand = $ExtensionShellOpenDelegate = $null
            $OpenCommandKey = Get-ItemProperty "$($ClassesRootPath)\$($Extension)\shell\Open\command" -ErrorAction SilentlyContinue
            if($OpenCommandKey) {
                $ExtensionShellOpenCommand = $OpenCommandKey.'(default)'
                $ExtensionShellOpenDelegate = $OpenCommandKey.'DelegateExecute'
            }

            # TODO: Make ProgId shell open command enumeration robust
            $ProgIdShellOpenCommand = $ProgIdShellOpenDelegate = $null
            $ProgIdCustomShellCommand = $ProgIdCustomShellDelegate = $null
            if($ExtObj.ProgId) {
                $OpenCommandKey = Get-ItemProperty "$($ClassesRootPath)\$($ExtObj.ProgId)\shell\Open\command" -ErrorAction SilentlyContinue
                $ProgIdShellOpenCommand = $OpenCommandKey.'(default)'
                $ProgIdShellOpenDelegate = $OpenCommandKey.'DelegateExecute'

                # ugh, copied from the ExtensionCustomShellCommand stuff below
                $ProgIdShellKey = Get-Item "$($ClassesRootPath)\$($ExtObj.ProgId)\Shell" -ErrorAction SilentlyContinue
                if($ProgIdShellKey) {
                    $ProgIdShellSubKeys = $ProgIdShellKey.GetSubkeyNames()
                    if($ProgIdShellSubKeys -inotcontains 'open' -and $ProgIdShellSubKeys.Count -eq 1) {
                        $ProgIdShellCustomKey = Get-ItemProperty "$($ClassesRootPath)\$($ExtObj.ProgId)\Shell\$($ProgIdShellSubKeys[0])\command\" -ErrorAction SilentlyContinue
                        $ProgIdCustomShellCommand = $ProgIdShellCustomKey.'(default)'
                        $ProgIdCustomShellDelegate = $ProgIdShellCustomKey.DelegateExecute
                    }
                    $ProgIdShellKey.Close()
                }
            }

            # TODO: Make robust
            $ExtensionOpenWithProgIds = $null
            $ExtensionOpenWithProgIdsKey = Get-Item "$($ClassesRootPath)\$($Extension)\OpenWithProgIds" -ErrorAction SilentlyContinue
            if($ExtensionOpenWithProgIdsKey) {
                $ExtensionOpenWithProgIds = $ExtensionOpenWithProgIdsKey.GetSubkeyNames()
                $ExtensionOpenWithProgIds += $ExtensionOpenWithProgIdsKey.GetValueNames()
                $ExtensionOpenWithProgIdsKey.Close()
            }

            # TODO: Make robust
            $ExtensionCustomShellCommand = $ExtensionCustomShellDelegate = $null
            $ExtensionShellKey = Get-Item "$($ClassesRootPath)\$($Extension)\Shell" -ErrorAction SilentlyContinue
            if($ExtensionShellKey) {
                $ExtensionShellSubKeys = $ExtensionShellKey.GetSubkeyNames()
                if($ExtensionShellSubKeys -inotcontains 'open' -and $ExtensionShellSubKeys.Count -eq 1) {
                    $ExtensionShellCustomKey = Get-ItemProperty "$($ClassesRootPath)\$($Extension)\Shell\$($ExtensionShellSubKeys[0])\command\" -ErrorAction SilentlyContinue
                    $ExtensionCustomShellCommand = $ExtensionShellCustomKey.'(default)'
                    $ExtensionCustomShellDelegate = $ExtensionShellCustomKey.DelegateExecute
                } elseif($ExtensionShellSubKeys -inotcontains 'open' -and $ExtensionShellSubKeys.Count -gt 1) {
                    Write-Warning "The extension '$($ExtObj.Extension)' has more than one shell handler that's not an 'open' handler"
                }
                $ExtensionShellKey.Close()
            }


            $RegTreeExtension = $RegTreeProgId = $RegTreeClsid = $null
            $RegTreeExtension = (Get-FlattenedRegistryKey -Path "$($RootPath)\$($Extension)" -ErrorAction SilentlyContinue | Format-FlattenedRegistryKey | out-string) #-replace "`r`n","|||"
            if($ExtObj.ProgId) {
                $RegTreeProgId = (Get-FlattenedRegistryKey -Path "$($RootPath)\$($ExtObj.ProgId)" -ErrorAction SilentlyContinue | Format-FlattenedRegistryKey | out-string) #-replace "`r`n","|||"
            }
            if($ComObj.Clsid) {
                $RegTreeClsid = (Get-FlattenedRegistryKey -Path "$($RootPath)\CLSID\$($ComObj.Clsid)" -ErrorAction SilentlyContinue | Format-FlattenedRegistryKey | out-string) #-replace "`r`n","|||"
            }

            New-Object PSObject -Property ([ordered]@{
                Name = $Extension
                ExtensionShellOpenCommand = $ExtensionShellOpenCommand
                ExtensionShellOpenDelegate = $ExtensionShellOpenDelegate
                ExtensionCustomShellCommand = $ExtensionCustomShellCommand
                ExtensionCustomShellDelegate = $ExtensionCustomShellDelegate
                ExtensionOpenWithProgIds = $ExtensionOpenWithProgIds #-join '|||'
                ProgId = $ExtObj.ProgId
                ProgIdShellOpenCommand = $ProgIdShellOpenCommand
                ProgIdShellOpenDelegate = $ProgIdShellOpenDelegate
                ProgIdCustomShellCommand = $ProgIdCustomShellCommand
                ProgIdCustomShellDelegate = $ProgIdCustomShellDelegate
                Clsid = $ComObj.Clsid
                ComObjectName = $ComObj.Name
                ComObjectInProcServer32 = $ComObj.InProcServer32
                ComObjectLocalServer32 = $ComObj.LocalServer32
                RegTreeExtension = $RegTreeExtension
                RegTreeProgId    = $RegTreeProgId
                RegTreeClsid     = $RegTreeClsid
            })
        }
    }
}

function Get-ClassicProtocolHandlers {
    [CmdletBinding()]
    Param(
        [Parameter(Position=0, Mandatory=$false)]
        [string[]]
        $ClassesRootPath = @('Registry::HKEY_CLASSES_ROOT','Registry::HKEY_CLASSES_ROOT\WOW6432Node')
    )


    foreach($HKCRRootPath in $ClassesRootPath) {
        $HKCR = Get-Item $HKCRRootPath

        foreach($SubKeyName in $HKCR.GetSubKeyNames()) {
            $SubKey = $HKCR.OpenSubKey($SubKeyName)
    
            if($SubKey.GetValueNames() -notcontains 'URL Protocol') {
                continue
            }

            $ShellOpenCommand = Get-ItemProperty -Path "$($HKCRRootPath)\$($SubKeyName)\shell\open\command" -ErrorAction SilentlyContinue
        
            if($ShellOpenCommand.DelegateExecute) {
                try {
                    $DelegateComObject = (Get-FlattenedRegistryKey -Path "$($HKCRRootPath)\CLSID\$($ShellOpenCommand.DelegateExecute)" -ErrorAction Stop) #| fl * | Out-string -Width 1000)#.Trim().Replace("`n","|||").Replace("`r","")
                } catch {
                    Write-Error "Could not find DelegateExecute CLSID $($ShellOpenCommand.DelegateExecute) specified by $($HKCRRootPath)\$($SubKeyName)\shell\open\command"
                    $DelegateComObject = $null
                }
            } else {
                $DelegateComObject = $null
            }

            
            New-Object PSObject -Property ([ordered]@{
                Scheme = $SubKeyName
                ShellOpenCommandDefault = $ShellOpenCommand.'(default)'
                ShellOpenCommandDelegate = $ShellOpenCommand.DelegateExecute
                DelegateComObjectTree = ($DelegateComObject | Format-FlattenedRegistryKey | Out-String) #-replace "`r`n","|||"
                KeyTree = (Get-FlattenedRegistryKey -Path "$($HKCRRootPath)\$($SubKeyName)" | Format-FlattenedRegistryKey | out-string) #-replace "`r`n","|||" # | fl * | Out-string -Width 1000)#.Trim().Replace("`n","|||").Replace("`r","")
                Path = "$($HKCRRootPath)\$($SubKeyName)"
            })
            

            $SubKey.Close()
        }

        $HKCR.Close()
    }
}


# File Extensions: .c5e2524a-ea46-4f67-841f-6a9465d9d515
#  - HKCR\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Extensions\windows.fileTypeAssociation\<Extension>\<ProgId> ! <PackageFullName>
#  - HKCR\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Extensions\windows.fileTypeAssociation\.c5e2524a-ea46-4f67-841f-6a9465d9d515\AppX8mn6f6acw2d3hves535dpq0zqnxqkec7 ! c5e2524a-ea46-4f67-841f-6a9465d9d515_10.0.16299.15_neutral_neutral_cw5n1h2txyewy
# 
# Protocols: zune://asdf
#  - HKCR\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Extensions\windows.protocol\<protocol>\<ProgId> ! <PackageFullName>
#  - HKCR\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Extensions\windows.protocol\zune\AppX7nv11hc795928dfdxbjgrnt50tez0eh7 ! Microsoft.WindowsStore_11805.1001.42.0_x64__8wekyb3d8bbwe
# 
# AppUriHandlers: These are apps that Edge will launch whenever a domain is visited
#  - HKCR\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Extensions\windows.appUriHandler\<[wildcarded]DomainName>\<ProgId> ! <PackageFullName>
#  - HKCR\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Extensions\windows.appUriHandler\*.maps.windows.com\AppXw2ahfj46c0qbns74sb1bad9a5cpw8042 ! Microsoft.WindowsMaps_5.1711.10477.1000_x64__8wekyb3d8bbwe
#  - HKCR\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Extensions\windows.appUriHandler\maps.windows.com\AppXpmv5ep1jbsan9pzb5ys5a2x5244nckxh   ! Microsoft.WindowsMaps_5.1711.10477.1000_x64__8wekyb3d8bbwe
function Get-UWPHandlers {
    [CmdletBinding()]
    Param(
        [Parameter(Position=0, Mandatory=$false)]
        [ValidateSet('FileExtensionHandler','ProtocolHandler','AppUriHandler')]
        [string]
        $Type = 'FileExtensionHandler',

        [Parameter(Position=1, Mandatory=$false)]
        [string]
        $ClassesRootPath = 'Registry::HKEY_CLASSES_ROOT'
    )

    $HandlerKey = $null
    switch($Type) {
        'FileExtensionHandler' {$HandlerKey = 'windows.fileTypeAssociation'}
        'ProtocolHandler'      {$HandlerKey = 'windows.protocol'}
        'AppUriHandler'        {$HandlerKey = 'windows.appUriHandler'}
        default {throw "Invalid handler type $($Type)"}
    }

    $ProtocolsKey = Get-Item "$($ClassesRootPath)\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Extensions\$($HandlerKey)" -ErrorAction SilentlyContinue
    if(-not $ProtocolsKey) {
        throw "Could not find $($ClassesRootPath)\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Extensions\$($HandlerKey)"
    }

    foreach($ProtocolName in $ProtocolsKey.GetSubKeyNames()) {
        
        $ProtocolKey = $ProtocolsKey.OpenSubKey($ProtocolName)

        foreach($ProgId in  $ProtocolKey.GetSubKeyNames()) {
            $ProgIdKey = Get-Item "$($ClassesRootPath)\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Extensions\ProgIDs\$($ProgId)"

            # There should only be one package for each ProgId, but let's just be safe
            foreach($PackageName in $ProgIdKey.GetValueNames()) {
                $AppXPackage = $EntryPoint = $Executable = $InstallationPath = $null

                try {
                    $AppXPackage = Get-UWPPackage -Name $PackageName -ClassesRootPath $ClassesRootPath -ErrorAction SilentlyContinue
                    if($AppXPackage) {
                        $EntryPoint = $AppXPackage.EntryPoint
                        $Executable = $AppXPackage.Executable
                        $InstallationPath = $AppXPackage.InstallationPath
                    } else {
                        $EntryPoint = $Executable = $InstallationPath = $null
                    }

                    New-Object PSObject -Property ([ordered]@{
                        Name = $ProtocolName
                        ProgId = $ProgId
                        PackageFullName = $PackageName
                        Executable = $Executable
                        EntryPoint = $EntryPoint
                        InstallationPath = $InstallationPath
                        RegistrationKey = "$($ProtocolsKey)\$($ProtocolName)"
                    })
                } catch {
                    Write-Error "Failed to process Universal App protocol $ProtocolName.  $($_.Exception.Message)"
                }
            }

            $ProgIdKey.Close()
        }

        $ProtocolKey.Close()
    }

    $ProtocolsKey.Close()
}


function Get-ShellFolderExtensions {
    [CmdletBinding()]
    Param(
        [Parameter(Position=1, Mandatory=$false)]
        [string[]]
        $ClassesRootPath = @('Registry::HKEY_CLASSES_ROOT')
    )

    $Keys = Get-ChildItem Registry::HKEY_CLASSES_ROOT\CLSID\*\ShellFolder | Select-Object -ExpandProperty PSParentPath
    foreach($Key in $Keys) {
        $LastSlash = $Key.LastIndexOf('\')
        $Clsid = $Key.Substring($LastSlash+1)

        Get-ComObject -Clsid $Clsid

    }
}

function Format-FlattenedRegistryKey {
    [CmdletBinding()]
    Param(
        [Parameter(Position=0, Mandatory=$false, ValueFromPipeline=$true)]
        [psobject[]]
        $InputObject
    )

    Process {
        if($InputObject) {
            foreach($Obj in $InputObject) {
                "$($Obj.Key)\$($Obj.ValueName) ! $($Obj.Value)"
            }
        }
    }
}


#region Auxillaryfunctions

function Get-ShellExSubkeyHandlers {
    [CmdletBinding()]
    Param(
        [Parameter(Position=0, Mandatory=$true)]
        [string]
        $Path,

        [Parameter(Position=1, Mandatory=$true)]
        [string]
        $Type,

        [Parameter(Position=2, Mandatory=$false)]
        [string]
        $ClassesRootPath = 'Registry::HKEY_CLASSES_ROOT'
    )

    $Key = Get-Item -Path $Path
    foreach($HandlerName in $Key.GetSubKeyNames()) {
        $HandlerKey = $Key.OpenSubKey($HandlerName)

        $HandlerValue = $HandlerKey.GetValue('','')

        if($HandlerName.StartsWith('{')) {
            $HandlerClsid = $HandlerName
        } else {
            $HandlerClsid = $HandlerValue
        }

        New-Object PSObject -Property @{
            HandlerType = $Type
            #Name = $HandlerName
            #Value = $HandlerValue
            CLSID = $HandlerClsid
            ClsidDescription = (Get-ItemProperty -Path "$($ClassesRootPath)\CLSID\$($HandlerClsid)" -Name '(default)' -ErrorAction SilentlyContinue).'(default)'
            Path = "$($Path)\$HandlerName ! (default)"
            #CLSIDKey = Get-Clsid $HandlerClsid
        }

        $HandlerKey.Close()
    }
    $Key.Close()
}

function Get-ShellSingleValueHandler {
    [CmdletBinding()]
    Param(
        [Parameter(Position=0, Mandatory=$true)]
        [string]
        $Path,

        [Parameter(Position=1, Mandatory=$true)]
        [string]
        $Type,

        [Parameter(Position=2, Mandatory=$false)]
        [string]
        $ClassesRootPath = 'Registry::HKEY_CLASSES_ROOT'
    )

    $Key = Get-ItemProperty -Path $Path -ErrorAction SilentlyContinue

    $HandlerClsid = $Key.'(default)'

    New-Object PSObject -Property @{
        HandlerType = $Type
        #Name = $Key.PSChildName
        #Value = $HandlerClsid
        CLSID = $HandlerClsid
        ClsidDescription = (Get-ItemProperty -Path "$($ClassesRootPath)\CLSID\$($HandlerClsid)" -Name '(default)' -ErrorAction SilentlyContinue).'(default)'
        Path = "$($Path) ! (default)"
        #CLSIDKey = Get-Clsid $HandlerClsid
    }
}

function Get-ShellExtension {
    [CmdletBinding()]
    Param(
        [Parameter(Position=0, Mandatory=$true)]
        [string]
        $Path,

        [Parameter(Position=2, Mandatory=$false)]
        [string]
        $ClassesRootPath = 'Registry::HKEY_CLASSES_ROOT'
    )

    $RootKey = Get-Item -Path $Path -ErrorAction SilentlyContinue
    if($RootKey -eq $null) {
        throw "Could open registry path $Path"
    }

    foreach($SubkeyName in $RootKey.GetSubKeyNames()) {
        
        $HandlersWithSubkeys     = 'ContextMenuHandlers','CopyHookHandlers','DragDropHandlers','PropertySheetHandlers','ColumnHandlers'
        $HandlersWithASingleValueMap = @{
            'DataHandler' = 'DataHandler'
            'DropHandler' = 'DropHandler'
            'IconHandler' = 'IconHandler'
            'PropertyHandler' = 'PropertyHandler'
            '{0000000B-0000-0000-C000-000000000046}' = 'StructuredStorageHandler' # Structured storage	IStorage
            '{00021500-0000-0000-C000-000000000046}' = 'InfoTipHandler'           # Infotip handler	IQueryInfo
            '{000214EE-0000-0000-C000-000000000046}' = 'ShellLinkAHandler'        # Shell link (ANSI)	IShellLinkA
            '{000214F9-0000-0000-C000-000000000046}' = 'ShellLinkWHandler'        # Shell link (UNICODE)	IShellLinkW
            '{3D1975AF-0FC3-463d-8965-4DC6B5A840F4}' = 'MovieThumbnailHandler????'# Movie Thumbnails. Ex: HKEY_CLASSES_ROOT\.avi\ShellEx\shellex\{3D1975AF-0FC3-463d-8965-4DC6B5A840F4}
            '{8895b1c6-b41f-4c1c-a562-0d564250836f}' = 'PreviewHandler'           # Preview Handlers
            '{90AA3A4E-1CBA-4233-B8BB-535773D48449}' = 'TaskbarPinHandler'        # Pin to Taskbar
            '{a2a9545d-a0c2-42b4-9708-a0b2badd77c8}' = 'StartMenuPinHandler'      # Pin to Start Menu	IStartMenuPinnedList
            '{BB2E617C-0920-11d1-9A0B-00C04FC2D6C1}' = 'ImageHandler'             # Image handler	IExtractImage
            '{CABB0DA0-DA57-11CF-9974-0020AFD79762}' = 'PinnedSiteHandler'        # Interface used for getting the URL of pinned site shortcuts(https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.uitest.extension.iuniformresourcelocator.aspx). IUniformResourceLocator - HKEY_CLASSES_ROOT\.URL\ShellEx\shellex\{CABB0DA0-DA57-11CF-9974-0020AFD79762}
            '{e357fccd-a995-4576-b01f-234630154e96}' = 'ThumbnailHandler'         # Thumbnail image handler	IThumbnailProvider
            '{FBF23B80-E3F0-101B-8488-00AA003E56F8}' = 'InternetShortcutHandler'  # HKEY_CLASSES_ROOT\.URL\ShellEx\shellex\{FBF23B80-E3F0-101B-8488-00AA003E56F8}
        }

        if($HandlersWithSubkeys | ?{$_ -eq $SubkeyName}) {
            Get-ShellExSubkeyHandlers -Path "$($Path)\$($SubKeyName)" -Type $SubkeyName -ClassesRootPath $ClassesRootPath
        } elseif($HandlersWithASingleValueMap[$SubkeyName] -ne $null) {
            Get-ShellSingleValueHandler -Path "$($Path)\$($SubkeyName)"  -Type $HandlersWithASingleValueMap[$SubkeyName] -ClassesRootPath $ClassesRootPath
        } else {
            Write-Warning "Unhandled shell extension subkey: $Path\shellex\$Subkeyname"
        }
        <#
        #$SubkeyName
        switch($SubkeyName) {
            'ColumnHandlers' {
                # Column provider handler (deprecated in Windows Vista)	- IColumnProvider
                $Output.ColumnHandlers = Get-ShellExHandlers -Path "$($Path)\ColumnHandlers"
            }

            'ContextMenuHandlers' {
                # Shortcut menu handler	- IContextMenu
                $Output.ContextMenuHandlers = Get-ShellExHandlers -Path "$($Path)\ContextMenuHandlers"
            }
            'CopyHookHandlers' {
                # Copyhook handler - ICopyHook
                $Output.CopyHookHandlers = Get-ShellExHandlers -Path "$($Path)\CopyHookHandlers"
            }
            'DataHandler' {
                # Data handler - IDataObject
                $Output.DataHandler = (Get-ItemProperty -Path "$($Path)\DataHandler" -Name '(default)' -ErrorAction SilentlyContinue).'(default)'
            }
            'DragDropHandlers' {
                # Drag-and-drop handler - IContextMenu
                $Output.DragDropHandlers = Get-ShellExHandlers -Path "$($Path)\DragDropHandlers"
            }
            'DropHandler' {
                # Drop handler - IDropTarget
                $Output.DropHandler = (Get-ItemProperty -Path "$($Path)\DropHandler" -Name '(default)' -ErrorAction SilentlyContinue).'(default)'
            }

            'FolderExtensions' { $Output.FolderExtensions = 'NOT IMPLEMENTED YET' }
            
            'LibraryDescriptionHandler' { $Output.LibraryDescriptionHandler = 'NOT IMPLEMENTED YET' }
            
            'LocationDescriptionHandler' { $Output.LocationDescriptionHandler = 'NOT IMPLEMENTED YET' }
            
            'PropertyHandler' {
                # Metadata - IPropertyStore
                $Output.PropertyHandler = (Get-ItemProperty -Path "$($Path)\PropertyHandler" -Name '(default)' -ErrorAction SilentlyContinue).'(default)'
            }
            'PropertySheetHandlers' {
                # Property sheet handler - IShellPropSheetExt
                $Output.PropertySheetHandlers = Get-ShellExHandlers -Path "$($Path)\PropertySheetHandlers"
            }

            'SharingHandler' {$Output.SharingHandler = 'NOT IMPLEMENTED YET'}
            'StorageHandler' {$Output.StorageHandler = 'NOT IMPLEMENTED YET'}

            '{0000000B-0000-0000-C000-000000000046}' {} # Structured storage	IStorage
            '{00021500-0000-0000-C000-000000000046}' {} # Infotip handler	IQueryInfo
            '{000214EE-0000-0000-C000-000000000046}' {} # Shell link (ANSI)	IShellLinkA
            '{000214F9-0000-0000-C000-000000000046}' {} # Shell link (UNICODE)	IShellLinkW
            '{3D1975AF-0FC3-463d-8965-4DC6B5A840F4}' {} # Move Thumbnails. Ex: HKEY_CLASSES_ROOT\.avi\ShellEx\shellex\{3D1975AF-0FC3-463d-8965-4DC6B5A840F4}
            '{8895b1c6-b41f-4c1c-a562-0d564250836f}' {} # Image Preview Handler - https://docs.microsoft.com/en-us/windows/win32/shell/how-to-register-a-preview-handler
            '{90AA3A4E-1CBA-4233-B8BB-535773D48449}' {} # Pin to Taskbar
            '{a2a9545d-a0c2-42b4-9708-a0b2badd77c8}' {} # Pin to Start Menu	IStartMenuPinnedList
            '{BB2E617C-0920-11d1-9A0B-00C04FC2D6C1}' {} # Image handler	IExtractImage
            '{CABB0DA0-DA57-11CF-9974-0020AFD79762}' {} # Interface used for getting the URL of pinned site shortcuts(https://msdn.microsoft.com/en-us/library/microsoft.visualstudio.testtools.uitest.extension.iuniformresourcelocator.aspx). IUniformResourceLocator - HKEY_CLASSES_ROOT\.URL\ShellEx\shellex\{CABB0DA0-DA57-11CF-9974-0020AFD79762}
            '{e357fccd-a995-4576-b01f-234630154e96}' {} # Thumbnail image handler	IThumbnailProvider
            '{FBF23B80-E3F0-101B-8488-00AA003E56F8}' {} # HKEY_CLASSES_ROOT\.URL\ShellEx\shellex\{FBF23B80-E3F0-101B-8488-00AA003E56F8}


            default { Write-Warning "Unhandled shell extension subkey: $Path\shellex\$Subkeyname" }
        }#>

    }

    $RootKey.Close()
}

#Get-ShellExtensionHandler -Path Registry::HKEY_CLASSES_ROOT\AllFilesystemObjects\shellex\

function Get-FileHandlerObject {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true, Position=0, ValueFromPipeline=$true)]
        [string[]]
        $Extension,

        [Parameter(Position=1, Mandatory=$false)]
        [string]
        $ClassesRootPath = 'Registry::HKEY_CLASSES_ROOT'
    )


    for($i=0; $i -lt $Extension.Count; $i++) {
        if(!$Extension[$i].StartsWith('.')) {
            $Extension[$i] = ".$($Extension[$i])"
        }
    }

    $Output = [ordered]@{}

    # | %{
    $Extension | %{
        $Output = [ordered]@{
            DontCompressInPackage = $false
            Extension = $_
            FriendlyTypeName = $null
            FullDetails = $null
            Generic = $null
            InfoTip = $null
            PersistentHandler = $null
            PerceivedType = $null
            OpenWithProgids = $null
            NoOpen = $false
            ProgId = $null
            UnknownRootValues = $null
        }

        $RootKey = Get-Item -Path "$($ClassesRootPath)\$($_)"

        # 1) Handle root key values first
        $KnownValues = 'Content Type','FriendlyTypeName','FullDetails','Generic','InfoTip','PerceivedType','DontCompressInPackage','NoOpen'

        $Output.ProgId = $RootKey.GetValue('','')
        $Output.ContentType = $RootKey.GetValue('Content Type','')             # It appears people often use ContentType or Content-Type as well...
        $Output.FriendlyTypeName = $RootKey.GetValue('FriendlyTypeName','')
        $Output.FullDetails = $RootKey.GetValue('FullDetails','')
        $Output.Generic = $RootKey.GetValue('Generic','')
        $Output.InfoTip = $RootKey.GetValue('InfoTip','')
        $Output.PerceivedType = $RootKey.GetValue('PerceivedType', '')
        if($RootKey.GetValueNames() | ?{$_ -eq 'DontCompressInPackage'}) {
            $Output.DontCompressInPackage = $true
        }

        if($RootKey.GetValueNames() | ?{$_ -eq 'NoOpen'}) {
            $Output.NoOpen = $true
        }

        $UnknownRootValues = @()
        foreach($Name in $RootKey.GetValueNames()) {
            if($Name -ne '' -and !($KnownValues | ?{$_ -eq $Name})) {
                $UnknownRootValues += $Name
            }
        }
        if($UnknownRootValues.Count -gt 0) {
            $Output.UnknownRootValues = $UnknownRootValues
            Write-Warning "Found the following unexpected values in $($RootKey.Name): $($UnknownRootValues -join ',')"
        } 


        # 2) Deal with subkeys
        foreach($SubKeyName in $RootKey.GetSubKeyNames()) {
            $SubKey = $Rootkey.OpenSubKey($SubKeyName)

            switch ($SubKeyName) {
                'PersistentHandler' {
                    $Output.PersistentHandler = Get-ShellSingleValueHandler -Path "Registry::$($SubKey.Name)" -Type 'PersistentHandler' -ClassesRootPath $ClassesRootPath
                }

                'OpenWithProgids' {
                    $OpenWithProgIds = @()
                                        
                    $DefaultValue = $SubKey.GetValue('','')   # Example: .ppkg
                    if($DefaultValue -and $DefaultValue -ne '') {
                        $OpenWithProgIds += $DefaultValue
                    }

                    if($SubKey.ValueCount -gt 0) {
                        $OpenWithProgIds += $SubKey.GetValueNames() | Where-Object {$_}
                    }

                    if($OpenWithProgIds.Count -gt 0) {
                        $Output.OpenWithProgIds = $OpenWithProgIds
                    } else {
                        $Output.OpenWithProgIds = $null
                    }
                }

                'ShellEx' {
                    $Output.ShellEx = Get-ShellExtension -Path "$($RootKey.PSPath)\ShellEx" -ClassesRootPath $ClassesRootPath
                }
            }
        }

        New-Object PSObject -Property $Output
    }
}

function Get-ClsidFromProgId {
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true, ParameterSetName="ProgId")]
        [string[]]
        $ProgId,

        [Parameter(Position=1, Mandatory=$false)]
        [string]
        $ClassesRootPath = 'Registry::HKEY_CLASSES_ROOT'
    )

    Process {

        foreach($Id in $ProgId) {
            $Key = Get-Item -ErrorAction SilentlyContinue -Path "$($ClassesRootPath)\$($Id)"

            if(-not $Key) {
                Write-Error "ProgId '$($Id)' does not exist"
                continue
            }

            $Clsid = $null
            $Subkeys = $Key.GetSubKeyNames()
            $ValueNames = $Key.GetValueNames()

            # TODO: Determine what order the following 3 steps actually get processed in
            
            # 1) Account for CLSIDs
            if($Subkeys -icontains "CLSID") {
                $Clsid = $Key.OpenSubKey('CLSID').GetValue('')
            } elseif($ValueNames -icontains "CLSID") {
                $Clsid = $Key.GetValue('CLSID')
            }
            # 2) Account for CurVer keys/values
            elseif($Subkeys -icontains "CurVer") {
                $CurVer = $Key.OpenSubKey('CurVer').GetValue('')

                if($Id -ieq $CurVer) {
                    Write-Error "ProgId '$($Id)' does not have an associated CLSID. Has CurVer key, but it's self-referencing."
                    continue
                } else {
                    Write-Verbose "ProgId '$($Id)' has a CurVer subkey of '$($CurVer)'. Looking it up..."
                    $Clsid = Get-ClsidFromProgId -ProgId $CurVer -ClassesRootPath $ClassesRootPath
                }
            } elseif($ValueNames -icontains "CurVer") {
                $CurVer = $Key.GetValue('CurVer')
                
                if($Id -ieq $CurVer) {
                    Write-Error "ProgId '$($Id)' does not have an associated CLSID. Has CurVer value, but it's self-referencing."
                    continue
                } else {
                    Write-Verbose "ProgId '$($Id)' has a CurVer value of '$($CurVer)'. Looking it up..."
                    $Clsid = Get-ClsidFromProgId -ProgId $CurVer -ClassesRootPath $ClassesRootPath
                }
            } 
            # 3) No CLSID/CurVer
            else {
                Write-Error "ProgId '$($Id)' does not have an associated CLSID"
                continue
            }

            try {
                $null = [guid]::Parse($Clsid)
            } catch {
                Write-Error "ProgId '$($Id)' has a CLSID registered, but it is not a GUID. Actual value: $($Clsid)"
                continue
            }

            $Clsid
        }
    
    }
}

function Get-ComObject {
    [CmdletBinding(DefaultParameterSetName='ProgId')]
    Param(
        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true, ParameterSetName="ProgId")]
        [string[]]
        $ProgId,

        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true, ParameterSetName="Clsid")]
        [string[]]
        $Clsid,

        [Parameter(Position=2, Mandatory=$false)]
        [string]
        $ClassesRootPath = 'Registry::HKEY_CLASSES_ROOT'
    )

    Process {
        $InputClsids = $null
        if($PSCmdlet.ParameterSetName -eq 'ProgId') {
            $InputClsids = $ProgId | Get-ClsidFromProgId -ClassesRootPath $ClassesRootPath
        } else {
            $InputClsids = $Clsid | %{ $c = $_; try { $null = [guid]::Parse($c); $c } catch { Write-Error "The input CLSID '$($c)' is not a GUID"} }
        }

        foreach($InputClsid in $InputClsids) {
            $Output = [ordered]@{
                Clsid                 = $InputClsid
                Name                  = $null
                InProcServer32        = $null
                ImplementedCategories = $null
            }

            $RootKey = Get-Item -ErrorAction SilentlyContinue -Path "$($ClassesRootPath)\CLSID\$($InputClsid)"
            if(!$RootKey) {
                Write-Error "The CLSID '$($InputClsid)' is not present in the Registry"
                continue
            }

            $Output['Name'] = $RootKey.GetValue('')

            # 1) Process COM object's subkeys
            foreach($RootSubKeyName in $RootKey.GetSubKeyNames()) {
                $SubKey = Get-Item -Path "$($ClassesRootPath)\CLSID\$($InputClsid)\$($RootSubKeyName)"

                switch($RootSubKeyName.ToLower()) {
                    'implemented categories' {
                        $Output['ImplementedCategories'] = $SubKey.GetSubKeyNames()
                    }

                    'inprocserver32' {
                        $Output['InProcServer32'] = $SubKey.GetValue('')
                    }

                    'localserver32' {
                        $Output['LocalServer32'] = $SubKey.GetValue('')
                    }

                    default {
                        Write-Warning "Unknown COM key '$($RootSubKeyName)' when processing CSLID '$($InputClsid)'"
                    }
                }

                $SubKey.Close()
            }

            # 2) Process COM object's value

            New-Object psobject -Property $Output

            $RootKey.Close()
        }
    }
}

function Get-FlattenedRegistryKey {
    [CmdletBinding()]
    Param(
        [Parameter(Position=0, Mandatory=$true)]
        $Path,

        [Parameter(Position=1, Mandatory=$false)]
        [int]
        $Depth,

        [Parameter(Position=2, Mandatory=$false)]
        [Regex]
        $SearchTerm
    )
    
    function GetFlattenedRegistryKey {
        [CmdletBinding()]
        Param(
            [Parameter(Position=0, Mandatory=$true)]
            $Path,

            [Parameter(Position=1, Mandatory=$false)]
            [int]
            $Depth,

            [Parameter(Position=2, Mandatory=$false)]
            [Regex]
            $SearchTerm
        )

        $KeyName = $Path.Substring($Path.LastIndexOf('\')+1)

        #1) Get the properties of the current key
        try {
            $Key = Get-Item -LiteralPath $Path -ErrorAction Stop
        } catch {
            Write-Error "$($_.Exception.Message) Location: $Key"
            $Key = $null
        }

        if($Key) {
            $ValueNames = $Key.GetValueNames()


            # Sometimes GetValueNames doesn't include the default value, so let's explicitly grab it

            New-Object PSObject -Property ([ordered]@{
                Key = "$($Key.PSPath)\".Replace($script:g_ParentKeyName, '')
                ValueName = '(default)'
                Value = $Key.GetValue('',$null)
            })


            foreach($ValueName in $ValueNames) {
                
                if($ValueName -eq '') {
                    # Already dealt with default value above
                    continue
                }

                try {
                    $Value = $Key.GetValue($ValueName,$null)

                    New-Object PSObject -Property ([Ordered]@{
                        Key = "$($Key.PSPath)\".Replace($script:g_ParentKeyName, '')
                        ValueName = $ValueName
                        Value = $Value
                    })
                } catch {
                    
                    Write-Error $_
                }
            }

            # 2) Get the values in the subkeys
            foreach($SubkeyName in $Key.GetSubKeyNames()) {
                GetFlattenedRegistryKey -Path "$($Key.PSPath)\$($SubKeyName)" -Depth $Depth -SearchTerm $SearchTerm
            }
        }
    }
    

    $RootKeys = Get-Item -Path $Path -ErrorAction SilentlyContinue

    if($RootKeys) {
        foreach($Root in $RootKeys) {
            $script:g_ParentKeyName = "$($Root.PSParentPath)\"
            GetFlattenedRegistryKey -Path $Root.PSPath 
        }
    } else {
        Write-Error "Could not find root key $Path"
    }

    Remove-Variable -Scope Script -Name g_ParentKeyName -ErrorAction SilentlyContinue
}

function Get-ProgId {
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory=$true)]
        $Id
    )

    Get-FlattenedRegistryKey -Path "Registry::HKEY_CLASSES_ROOT\$Id"
}

function Get-ProgIds {
    [CmdletBinding()]
    Param(
        [string]
        $Name
    )

    $RootKeys = 'Registry::HKEY_CLASSES_ROOT','Registry::HKEY_CLASSES_ROOT\WOW6432Node'

    foreach($RootKeyName in $RootKeys) {
        $RootKey = Get-Item $RootKeyName
        
        $ProgIdNames = $RootKey.GetSubKeyNames() | ?{ !$_.StartsWith('.') -and $_ -notmatch '^(CLSID|AppId|\*|DirectShow|Interface|Media Type|Media Foundation|PROTOCOLS|TypeLib|AppUserModelId|Applications|ActivatableClasses|AudioEngine|Local Settings|Component Categories|Extensions|Installer|Mime|Licenses|Record|SystemFileAssociations|Software|Unmarshalers|WOW6432Node|Media Type|MediaFoundation|VirtualStore|PackagedCom)$'}
        foreach($ProgId in $ProgIdNames) {
            Get-FlattenedRegistryKey -Path "$RootKeyName\$ProgId"
        }

        $RootKey.Close()
    }
}

function Get-ClsId {
    [CmdletBinding()]
    Param (
        $Id,

        [switch]
        $X86
    )

    if($X86) {
        $Root = "Registry::HKEY_CLASSES_ROOT\WOW6432Node"
    } else {
        $Root = "Registry::HKEY_CLASSES_ROOT"
    }

    if($Id -match '^\{[a-zA-Z0-9]{8}-([a-zA-Z0-9]{4}-){3}[a-zA-Z0-9]{12}\}$') {
        Get-FlattenedRegistryKey -Path "$Root\CLSID\$Id"
    } elseif($Id -match '^[a-zA-Z0-9]{8}-([a-zA-Z0-9]{4}-){3}[a-zA-Z0-9]{12}$') {
        Get-FlattenedRegistryKey -Path "$Root\CLSID\`{$Id`}"
    } else {
        throw "Invalid CLSID format"
    }
}

function Get-UWPPackage {
    [CmdletBinding()]
    Param(
        [Parameter(Position=0, Mandatory=$true)]
        [string]
        $Name,

        [Parameter(Position=1, Mandatory=$false)]
        [string]
        $ClassesRootPath = 'Registry::HKEY_CLASSES_ROOT'
    )

    $PackageProperties = Get-ItemProperty "$($ClassesRootPath)\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Packages\$($Name)\" -ErrorAction SilentlyContinue

    if($PackageProperties) {
        foreach($Package in $PackageProperties) {

            $ManifestXml = Get-Content "$($Package.Path)\AppxManifest.xml" -ErrorAction SilentlyContinue
            # We found the package, so let's get the entry point
            if($ManifestXml) {
                #$Manifest = [xml](Get-Content -Path "$Path\appxmanifest.xml")
                $Manifest = [xml]$ManifestXml

                $Executable = $Manifest.Package.Applications.Application.Executable -join ','
                $EntryPoint = $Manifest.Package.Applications.Application.EntryPoint -join ','
            } else {
                $Executable = $EntryPoint = $null
            }

            New-Object PSObject -Property @{
                InstallationPath = $Package.Path
                Executable = $Executable
                EntryPoint = $EntryPoint
                ManifestFile = [bool]$ManifestXml
            }
        }
    } else {
        Write-Error "Could not find any packages matching '$($Name)'"
    }
}
#endregion Auxillary functions