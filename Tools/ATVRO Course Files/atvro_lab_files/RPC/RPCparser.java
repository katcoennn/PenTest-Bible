//RPC server code seeker
//@author Sektor7 Labs (reenz0h)
//@category Functions
//@keybinding 
//@menupath 
//@toolbar

import ghidra.app.script.GhidraScript;
import ghidra.program.model.util.*;
import ghidra.program.model.reloc.*;
import ghidra.program.model.data.*;
import ghidra.program.model.block.*;
import ghidra.program.model.symbol.*;
import ghidra.program.model.scalar.*;
import ghidra.program.model.mem.*;
import ghidra.program.model.listing.*;
import ghidra.program.model.lang.*;
import ghidra.program.model.pcode.*;
import ghidra.program.model.address.*;
import java.util.Arrays;

public class RPCparser extends GhidraScript {

	// helper methods
	public long bytesToLong(byte[] bytes) {
		long value = 0;
		for (int i = 0; i < bytes.length; i++) {
		   value += ((long) bytes[i] & 0xffL) << (8 * i);
		}
		return value;
	}

	public int bytesToInt(byte[] bytes) {
		int value = 0;
		for (int i = 0; i < bytes.length; i++) {
		   value += ((int) bytes[i] & 0xffL) << (4 * i);
		}
		return value;
	}	
	
	public byte[] extractBytes(byte[] src, int idx, int len) {
		byte[] a = new byte[] {0x0};		
		try {
		    a = Arrays.copyOfRange(src, idx, idx + len);
		}
		catch (Exception e) {
			//
		}
		return a;
	}
	
	public Address convertToAddr(Long lAddr) {
		Address addr = currentProgram.getMinAddress();
		
		return addr = addr.add(lAddr - addr.getOffset()); // a hack, FIXME		
	}
	
	public byte[] readData(MemoryBlock block, Long src, int len) {
		Address addr = convertToAddr(src);
		byte[] data = new byte[(int) len];
		
		try {
			block.getBytes(addr, data);
		}
		catch (MemoryAccessException e) {
			// 
		}
		
		return data;
	}
	
	public boolean isInBlock(MemoryBlock block, long value) {
		if (value >= block.getStart().getOffset() && value <= block.getEnd().getOffset()) {
			return true;
		}
		else {
			return false;
		}
	}
	
	// main method
    	public void run() throws Exception {

		// get .text and .rdata memory segments
		MemoryBlock text_block = getMemoryBlock(".text");
		MemoryBlock rdata_block = getMemoryBlock(".rdata");
		
		// get segments' start and end addresses
		Address text_start = text_block.getStart();
		Address text_end = text_block.getEnd();
		Address rdata_start = rdata_block.getStart();
		Address rdata_end = rdata_block.getEnd();
		
		Listing pList = currentProgram.getListing();
		String funcName;
		
		// read up .rdata segment
		byte[] rdata_bytes = new byte[(int) rdata_block.getSize()];
		rdata_block.getBytes(rdata_start, rdata_bytes);
		long rdata_size = rdata_block.getSize();

		// start searching for RPC_SERVER_INTERFACE structures
		for (int i = 0; i < rdata_size; i++) {
			// print currently processed address
			Address b = rdata_start.add(i);
			monitor.setMessage(b.toString());
			monitor.checkCanceled();
			
			// get potential RPC_SERVER_INTERFACE struct size, DispatchTable, InterpreterInfo and ServerRoutineTable pointers
			// safety check - dont read over the buffer
			if (i + 8 >= rdata_size) {
				break;
			}
			int rpcStructSize = bytesToInt(extractBytes(rdata_bytes, i, 4));
			Long DispatchTablePtr = bytesToLong(extractBytes(rdata_bytes, i + 0x30, 8));
			Long InterpreterInfoPtr = bytesToLong(extractBytes(rdata_bytes, i + 0x50, 8));
			Long offset = InterpreterInfoPtr - rdata_start.getOffset() + 8;
			Long ServerRoutineTablePtr = bytesToLong(extractBytes(rdata_bytes, offset.intValue() , 8));

			// verify if these pointers are valid
			if (rpcStructSize <= 0 || DispatchTablePtr <= 0 || InterpreterInfoPtr <= 0 || ServerRoutineTablePtr <= 0) {
				continue;
			}
			if (rpcStructSize < 0x100 &&
				isInBlock(rdata_block, DispatchTablePtr) && 
			    isInBlock(rdata_block, InterpreterInfoPtr) && 
				isInBlock(rdata_block, ServerRoutineTablePtr)) {
				
				int dispatchTableCount = bytesToInt(readData(rdata_block, DispatchTablePtr, 4));

				// DispatchTableCount is usually a low value
				if (dispatchTableCount < 500) {
					//println("Functions found (FUNCTION_NAME, OFFSET):");
					
					for (int j = 0; j < dispatchTableCount; j++) {
						Long funcPtr = bytesToLong(readData(rdata_block, ServerRoutineTablePtr + j*8, 8));
						if (isInBlock(text_block, funcPtr)) {
							try {
								//Function f = pList.getFunctionAt(convertToAddr(funcPtr));
								Symbol f = getSymbolAt(convertToAddr(funcPtr));
								funcName = f.getName();
							}
							catch (Exception e) { // When getFunctionAt() used, some functions are not recognized. Ghidra bug?
								funcName = "__UNRESOLVED()";
							}
							println(funcName + "," + Long.toHexString(funcPtr));
						}
					}
					i += rpcStructSize - 1;
				}
			}	
		}
    	}

}

